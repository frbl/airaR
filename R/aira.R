#rm(list=ls(pos='.GlobalEnv',all=TRUE),pos='.GlobalEnv')

myPsi.varest <-
  function(x, nstep=10, ...){
    if(!(class(x)=="varest")){
      stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
    }
    nstep <- abs(as.integer(nstep))
    Phi <- Phi(x, nstep = nstep)
    Psi <- array(0, dim=dim(Phi))

    # Params contains all exo parameters
    params <- ncol(x$datamat[, -c(1:x$K)])

    # This is more or less equal to the covariance matrix
    # cov(resid(x)) - (crossprod(resid(x)) / (x$obs-1)) == 0
    sigma.u <- crossprod(resid(x)) / (x$obs - params)
    #sigma.u <- (crossprod(resid(x)) / (x$obs-14))
    P <- t(chol(sigma.u))
    #if(1 == 1) {
    #  P <- t(P)
    #}

    dim3 <- dim(Phi)[3]
    for(i in 1:dim3){
      Psi[, , i] <- Phi[, , i] %*% P
    }
    return(Psi)
  }

override_function <- function(origfuncname,packagename,newfunc) {
  failed <- FALSE
  tryCatch(unlockBinding(origfuncname, as.environment(paste("package:",packagename,sep=''))),
           error=function(e) failed <<- TRUE)
  if (!failed) assign(origfuncname, newfunc, paste("package:",packagename,sep=''))
  unlockBinding(origfuncname, getNamespace(packagename))
  assign(origfuncname, newfunc, getNamespace(packagename))
}
override_function("Psi.varest","vars",myPsi.varest)

#' The aira main class.
#'
#' @field bootstrap_iterations the number of bootstrap iterations to do for determining the significance of the effects
#' @field horizon the number of steps to look in the future
#' @field var_model the var model to perform the calculations on
#' @field orthogonalize use orthogonalized IRF
#' @importFrom vars VAR irf Bcoef Phi
#' @importFrom methods setRefClass
#' @export Aira
#' @exportClass Aira
Aira <- setRefClass('Aira',
  fields = c(
    "bootstrap_iterations",
    "horizon",
    "var_model",
    "orthogonalize"
  ),
  methods = list(
    determine_best_node_from_all = function() {
      "Returns the total effect a variable has on all other variables in the network.
      If bootstrap iterations provided to aira is 0, we will not run any bootstrapping.
      If bootstrap iterations >0, we will only consider the significant effects in the response"
      total <- list()
      for (variable in 1:var_model$K) {
        variable_name <- .get_variable_name(variable)
        total[variable_name] <- .calculate_irf(variable_name)
      }
      total
    },

    determine_percentage_effect  = function(variable_to_improve, percentage) {
      "Returns the percentage for each variable in the network (other then the provided variable)
      to be changed in order to change the variable_to_improve with the given percentage.
      @param variable_to_improve the name of the variable in the network which we'd like to improve
      @param percentage the percentage with which we'd like to improve the variable to improve"
      total <- list()
      for (variable in 1:var_model$K) {
        variable_name <- .get_variable_name(variable)
        if (variable_name == variable_to_improve)
          next

        effect <- .calculate_irf(variable_name, variable_to_improve)
        if (abs(effect) < 0.0001) {
          # TODO: do something, return null or infinity
          next
        }

        needed_difference <- mean(var_model$y[,variable_to_improve]) * (percentage / 100)
        needed_difference <- needed_difference / effect
        needed_difference <- needed_difference / mean(var_model$y[,variable_name])

        total[variable_name] <- needed_difference
      }
      total
    },

    get_all_variable_names = function() {
      "returns all variables in the var model"
      dimnames(var_model$y)[[2]]
    },

    .get_variable_name = function(id) {
      get_all_variable_names()[[id]]
    },
    .calculate_irf = function(variable_name, response = NULL, plot_results = FALSE){
      resulting_score <- 0
      if (bootstrap_iterations > 0) {
        result <- vars::irf(var_model, impulse=variable_name,
                 response = response, n.ahead = horizon, cumulative= FALSE,
                 boot = bootstrap_iterations, ortho = orthogonalize)

        if (plot_results) plot(result)
        low <- (result$Lower[[variable_name]] * (result$Lower[[variable_name]] > 0))
        high <- (result$Upper[[variable_name]] * (result$Upper[[variable_name]] < 0))
        sign_effects <- (low + high)[, !dimnames(result$Lower[[variable_name]])[[2]] %in% variable_name]
        resulting_score <- sum(sign_effects)
      } else {
        result <- vars::irf(var_model, impulse=variable_name, response = response, n.ahead = horizon, cumulative= FALSE, ortho = orthogonalize, boot= FALSE)
        if (plot_results) plot(result)
        result <- result$irf[[variable_name]][, !dimnames(result$irf[[variable_name]])[[2]] %in% variable_name, drop=FALSE]
        resulting_score <- as.numeric(colSums(result))
      }
      resulting_score
    }
  )
)

