rm(list=ls(pos='.GlobalEnv',all=TRUE),pos='.GlobalEnv')

#install.packages("vars")
library('vars')
library('devtools')
library('autovar',character.only=TRUE)

myPsi.varest <-
  function(x, nstep=10, ...){
    if(!(class(x)=="varest")){
      stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
    }
    nstep <- abs(as.integer(nstep))
    Phi <- Phi(x, nstep = nstep)
    Psi <- array(0, dim=dim(Phi))

    # Params contains all exo parameters
    params <- ncol(x$datamat[, -c(1:x$K)])

    # This is more or less equal to the covariance matrix
    # cov(resid(x)) - (crossprod(resid(x)) / (x$obs-1)) == 0
    sigma.u <- crossprod(resid(x)) / (x$obs - params)
    #sigma.u <- (crossprod(resid(x)) / (x$obs-14))
    P <- t(chol(sigma.u))
    if(ORDER == 1) {
      P <- t(P)
    }

    dim3 <- dim(Phi)[3]
    for(i in 1:dim3){
      Psi[, , i] <- Phi[, , i] %*% P
    }
    return(Psi)
  }

override_function <- function(origfuncname,packagename,newfunc) {
  failed <- FALSE
  tryCatch(unlockBinding(origfuncname, as.environment(paste("package:",packagename,sep=''))),
           error=function(e) failed <<- TRUE)
  if (!failed) assign(origfuncname, newfunc, paste("package:",packagename,sep=''))
  unlockBinding(origfuncname, getNamespace(packagename))
  assign(origfuncname, newfunc, getNamespace(packagename))
}
override_function("Psi.varest","vars",myPsi.varest)


Aira <- setRefClass('Aira',
  fields = c(
    "bootstrap_iterations",
    "steps",
    "var_model"
  ),
  methods = list(
    determine_best_node_from_all = function() {
      total <- list()
      for (variable in 1:var_model$K) {
        variable_name <- .get_variable_name(variable)
        total[variable_name] <- .calculate_irf(variable_name)
        #print(x)
      }
      total
    },
    determine_percentage_effect  = function(variable_to_improve, percentage) {
      total <- list()
      for (variable in 1:var_model$K) {
        variable_name <- .get_variable_name(variable)
        if (variable_name == variable_to_improve)
          next

        effect <- .calculate_irf(variable_name, variable_to_improve)
        if (abs(effect) < 0.0001) {
          # do something, return null or infinity
          next
        }

        needed_difference <- mean(var_model$y[,variable_to_improve]) * (percentage / 100)
        needed_difference <- needed_difference / effect
        needed_difference <- needed_difference / mean(var_model$y[,variable_name])
        total[variable_name] <- needed_difference
      }
      total
    },
    .get_variable_name = function(id) {
      dimnames(var_model$y)[[2]][[id]]
    },
    .calculate_irf = function(variable_name, response = NULL){
      res <- 0
      if (bootstrap_iterations > 0) {
        x <- irf(var_model, impulse=variable_name, response = response, n.ahead = steps, cumulative= FALSE, boot = bootstrap_iterations, ortho = TRUE)
        plot(x)
        low <- (x$Lower[[variable_name]] * (x$Lower[[variable_name]] > 0))
        high <- (x$Upper[[variable_name]] * (x$Upper[[variable_name]] < 0))
        sign_effects <- (low + high)[, !dimnames(x$Lower[[variable_name]])[[2]] %in% variable_name]
        res <- sum(sign_effects)
      } else {
        x <- irf(var_model, impulse=variable_name, response = response, n.ahead = steps, cumulative= FALSE, ortho = TRUE, boot= FALSE)

        x <- x$irf[[variable_name]][, !dimnames(x$irf[[variable_name]])[[2]] %in% variable_name, drop=FALSE]

        res <- as.numeric(colSums(x))

        print(res)
      }
      res
    }
  )
)

